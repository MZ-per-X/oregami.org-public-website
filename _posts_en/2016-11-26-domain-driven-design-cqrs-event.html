---
layout: post
title: Domain Driven Design, CQRS, Event Sourcing, Hexagonal Architecture & more
date: '2016-11-26T16:00:00.000+01:00'
author: Sebastian Eichholz
tags:
- Development
modified_time: '2016-11-27T19:25:00.390+01:00'
blogger_id: tag:blogger.com,1999:blog-337622940517465099.post-4344093078118189843
blogger_orig_url: http://oregami-en.blogspot.com/2016/11/domain-driven-design-cqrs-event.html
---

The road to the right <a href="https://en.wikipedia.org/wiki/Software_architecture" target="_blank">software architecture</a> can be very long. Especially when you're not a professional software architect who helps his customers with developing complex applications day by day.<div style="text-align: justify;">What will be the Oregami way to the right software architecture? If you've been monitoring our project from the beginning, you know that we threw over the chosen technologies one ore two times already. In the beginning I only had the classical <a href="https://en.wikipedia.org/wiki/Multitier_architecture" target="_blank">multi-tier architecture</a> in mind and mainly thought about which Java framework to use for persisting our game objects and which database software to use for that. Until today my mind changed in many ways.<!--more-->

When I started my first web project (<a href="http://www.kultpower.de/" target="_blank">kultpower.de</a>) about 15 years ago with PHP3, I did not reflect about what was the best way to do it. With Oregami, it's different - I want more quality. Therefore I am researching technologies for the development of complex software applications in every free minute I can find. If you take a look at the people I am <a href="https://twitter.com/sebeichholz/following" target="_blank">following</a> on Twitter, you might recognize some well known developers from whom I learned about things like <a href="https://projects.spring.io/spring-boot/" target="_blank">Spring Boot</a>, <a class="external-link" href="https://spring.io/understanding/HATEOAS" rel="nofollow" target="_blank">HATEOAS</a>, <a class="external-link" href="https://www.tytonmedia.com/blog/responsive-web-design-guide-beginners/" rel="nofollow" target="_blank">Responsive Web Design</a> and <a class="external-link" href="http://www.lukew.com/ff/entry.asp?933" rel="nofollow" target="_blank">Mobile First</a>, <a class="external-link" href="https://jwt.io/introduction/" rel="nofollow" target="_blank">JSON Web Tokens</a>, <a class="external-link" href="http://roca-style.org/" rel="nofollow" target="_blank">Roca-Style </a> and more.</div>

<div style="text-align: justify;">My latest "achievements" are - again - having a deep impact on the big picture of the Oregami application. This summer I finally got some time to get into the topic "Domain Driven Design" (DDD), which Wikipedia <a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank">describes</a> as an "approach to software development for complex needs by connecting the implementation to an evolving model." You might think "so what?". I read the book <span style="color: #252525;">"</span><a href="https://www.amazon.de/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577" target="_blank">Implementing Domain Driven Design</a><span style="color: #252525;">", which enlightened me in more than one way. Many of its topics are an obvious perfect match for Oregami development. During the last months, even before I knew about DDD, I found some similar solutions for small aspects of the whole thing myself, which creates a rather good feeling.</span></div>

<div style="text-align: justify;">But what is "Domain Driven Design" all about in the end? I will try to resume the major parts of DDD as I understand them:</div>
  <ul>
  	<li style="text-align: justify;">Domain experts work very closely together with developers to create a "<a href="http://martinfowler.com/bliki/UbiquitousLanguage.html" target="_blank">ubiquitous language</a>" and describe the domain model with that language.</li>
  	<li style="text-align: justify;">The complete business model is not modeled in one big, comprehensive model, but is instead divided into multiple, smaller sub domains ("bounded contexts") according to some special rules.</li>
  	<li style="text-align: justify;">You <a href="http://culttt.com/2014/04/30/difference-entities-value-objects/" target="_blank">distinguish</a> between "real" entities and value objects, the latter should be used as much as possible, because they are in many aspects more controllable than entities. This gives you some major technical advantages.</li>
  	<li style="text-align: justify;">Every Bounded Context (BC) consists of exactly one network of entities (<span style="color: #252525;">"</span><a class="external-link" href="http://martinfowler.com/bliki/DDD_Aggregate.html" rel="nofollow" target="_blank">Aggregate</a><span style="color: #252525;">"</span>) with one main entity which is called "Aggregate Root". If a transaction alters the state of the application, only one aggregate at a time is allowed to be changed. It's not allowed to change more than one aggregate in one transaction.</li>
  	<li style="text-align: justify;">A connection from one BC to another may only reference the aggregate root of that BC. The aggregate root is responsible for all rules of that model. It's not allowed to span rules over several BCs.<span style="color: #252525;"><br /></span></li>
  </ul>
<div style="text-align: justify;">During my investigations I also discovered the concept of the so-called "Hexagonal Architecture". Alistair Cockburn <a href="http://alistair.cockburn.us/Hexagonal+architecture" target="_blank">writes about it</a> with this essential sentence: "Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases." Wow, that's exactly how software should be: universally<span style="color: black;"> </span>useable, easy to expand and easy to test. This architecture concept is sometimes called "Ports and Adapters" or "Onion Architecture", too, starting from the inner application code of the core domain, going through the application service layer to the outer infrastructure, there are no dependencies from the inner to the outer parts. Doing this makes your core code independent of the technical infrastructure, which again leads to better testability (infrastructure "ports" can be swapped easily, e.g. with in-memory variants) and great extensibility (One can add an additional "adapter" to support more clients which use your software, e.g. via ReST or queues).</div>

<div style="text-align: justify;">Talking about DDD and hexagonal architectures, you often stumble upon concepts like CQRS and Event Sourcing. Let us begin with <a href="https://de.wikipedia.org/wiki/Event_Sourcing" target="_blank">Event Sourcing</a>, which describes that the state of every business object is defined by a sequence of events. In practice this means a total rejection of the classic (mostly relational) persistence of data, which directly updates (replaces) the database state with every change. Instead every change of state is triggered by an event. These events are stored in the application, and reading requests are answered by "replaying" the saved events in the same order as they occured. This leads to nothing less then greater scalability and reproducibility of all changes. The latter is exactly what we do need at Oregami with an authoring system where updates to the central domain data (games &amp; co) shall first be reviewed by peers before they are seen as permanent changes. Also suitable for this subject area is the concept of <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank">CQRS</a> (Command and Query Responsibility Segregation): all reading access to the application ("queries") is strictly separated from the writing access ("commands"), which has positive influences on scalability. In my mind's eye, I can virtually see Oregami's users sending their input through commands, whose corresponding changes are saved as events. After having been reviewed (we just have to replay the stored events) they can be stored permanently and from now on can be used for all public reading access. This leads us to the user interface of our application: Unlike in our present prototypes, which all use the principle of <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a>, we should better use a "command oriented" user interface, also known as <a href="https://cqrs.wordpress.com/documents/task-based-ui/" target="_blank">Task based UI</a>. This concept is perfectly suited for commands or tasks from the approaches described above. In our Oregami domain we might think of commands like "Create Game", "Add Release" or "Add Screenshot".</div>
  <div class="tw-ta-container tw-nfl">
  	<pre class="tw-data-text tw-ta tw-text-medium" lang="en" style="text-align: justify;"> </pre>
  	<div style="text-align: justify;">What will we do with these insights?</div>
  	<div style="text-align: justify;"><br /></div>
  </div>
  <div style="text-align: justify;">I can imagine the following steps:</div>
  <ol>
  	<li style="text-align: justify;">I will - again - start a new Git repository: Oregami-DDD or something like that.</li>
  	<li style="text-align: justify;">We identify our first Bounded Context, which we will implement after the rules of DDD</li>
  	<li style="text-align: justify;">We identify and create the necessary entities and value objects.</li>
  	<li style="text-align: justify;">We model appropriate use cases and implement them with a hexagonal architecture.</li>
  	<li style="text-align: justify;">Changes to data are always initiated by commands and are stored as events.</li>
  	<li style="text-align: justify;">The events must be displayable and reviewable, for the peer review process.</li>
  	<li>
  		<div style="text-align: justify;">Later on we will create more and more Bounded Contexts with the same ideas in mind to expand our application. It will be challenging to see how the different BCs communicate with each other and how the user interface can integrate multiple BCs. We will also have to see if we really do need a separated read model.</div>
  		<div style="text-align: justify;"><br /></div>
  	</li>
  </ol>
  <div style="text-align: justify;">For the interested reader here are some of my favorite sources for my inspirations:</div>
  <ul>
  	<li style="text-align: justify;">Vaughn Vernon: <a href="http://dddcommunity.org/library/vernon_2011/" target="_blank">Effective Aggregate Design</a> (PDFs: <a href="http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf" target="_blank">Part 1</a>, <a href="http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf" target="_blank">Part 2</a>, <a href="http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf" target="_blank">Part 3</a>)</li>
  	<li style="text-align: justify;">Paul Rayner: <a class="external-link" href="http://thepaulrayner.com/blog/aggregates-and-entities-in-domain-driven-design/" rel="nofollow" target="_blank">Aggregates &amp; Entities in Domain-Driven Design</a></li>
  	<li style="text-align: justify;">Alistair Cockburn: <a href="http://alistair.cockburn.us/Hexagonal+architecture" target="_blank">Hexagonal Architecture</a></li>
  	<li style="text-align: justify;">Slideset by Jeppe Cramon: <a href="http://www.slideshare.net/jeppec/agile-ddd-cqrs" target="_blank">Agile, Architecture, DDD and CQRS</a></li>
  	<li style="text-align: justify;">Martin Fowler: <a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank">Event Sourcing</a></li>
  	<li style="text-align: justify;">Torben Fojuth: <a href="https://www.informatik-aktuell.de/entwicklung/methoden/domain-driven-design-im-hexagon.html" target="_blank">Domain-Driven Design im Hexagon</a> (German)</li>
  	<li style="text-align: justify;">Kyle Cordes: <a href="http://kylecordes.com/2014/task-based-user-interfaces" target="_blank">Task Based User Interfaces</a></li>
  	<li style="text-align: justify;">Mehdi Khalili: <a href="http://www.mehdi-khalili.com/orm-anti-patterns-part-5-generic-update-methods/" target="_blank">ORM anti-patterns - Part 5: Generic update methods</a></li>
  </ul>
  
  Exciting times are ahead of us again, so stay tuned to Oregami!
